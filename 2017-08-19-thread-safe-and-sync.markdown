---
layout:     post
title:      "线程同步与安全 总结"
subtitle:   "线程的同步方式总结，线程死锁问题"
date:       2017-08-19
author:     "ChenWenKe"
header-img: "img/post-bg-zhuan-liwei.jpg"
tags:
    - C++
    - 多线程
---

# 线程安全与同步
**一个线程所特有的数据:** 线程ID, 栈, 栈指针，通用目的寄存器，程序计数器，条件码，信号屏蔽字，线程优先级。 

## 线程安全
- **可重入函数：** 当它们被多个线程调用时，不会引用任何共享数据。 可重入函数是线程安全函数的真子集。 

### 四类(不相交的)线程不安全函数：
1. 不保护共享变量的函数。 ——> 解决方法： 加锁同步。 
2. 保持跨越多个调用状态的函数。例如 `rand()`。 ——> 解决方法： 重写，使它不再使用任何 static 数据， 而是依靠调用者在参数中传递状态信息。 
3. 返回指向静态变量的指针的函数。 如 `ctime()`。 ——> 解决方法： 加锁—拷贝。
4. 调用线程不安全的函数。 ——> 解决方法： 使用上面三种方法，使之线程安全。 

### 死锁:
- 死锁定义： 指的是一组 线程/进程被阻塞了，等待一个永远不会为真的条件。 
- 死锁条件： 互斥条件， 不可抢占条件， 申请持有条件，循环等待条件。 
- 防止死锁： 预防死锁， 避免死锁， 检测与恢复。 

程序死锁的原因有很多，要避免死锁一般而言是很困难的。 然而，当使用二元信号量（或互斥锁）来实现互斥时，可以用以下方法避免死锁。 
> **互斥锁加锁顺序规则:** 如果对于程序中， 每对互斥锁(s, t)，给所有的锁分配一个全序，每个线程按照这个顺序来请求锁，并按照逆序来释放，那么这个程序就是无死锁的。 

## 线程同步
1. 信号量： 信号量就是一个计数器，不过其加减操作都是原子操作。 原子操作是内核用一条计算机指令 `CAS: compare and swap(set)` 进行实现的, 由于是一条计算机指令，所以不会出现 ABA问题。 
2. 互斥量： 互斥量从本质上来说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解放）互斥量。相当于二值信号量。 
3. 条件变量： 条件变量给多个线程提供了一个会合的场所，条件本身是由互斥量保护的。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生，进而调度对共享资源的访问。 
4. 读写锁：与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有 3 种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。 一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式下的读写锁。 
**读写锁非常适合于对于数据结构读的次数远大于写的情况。**
5. 自旋锁：自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一致处于**忙等**（自旋）阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。 另外：**自旋锁通常作为底层原语用于实现其他类型的锁。**
6. 屏障： 屏障(barrier)是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有合作线程都到达某一点，然后从该点继续执行。
7. 记录锁：记录锁的功能是: 当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。更确切地说，记录锁是字节范围锁，因为它锁定的只是文件中的一个区域（也可能是整个文件）。
	1. 不同进程之间共享性读锁和独占性写锁。 
	2. 对于同一进程而言，对同一文件区域重复加锁，新锁替换旧锁。 
	3. 在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。 

**锁的隐含继承和释放**：
	1. 锁与进程和文件相关联。这有两重含义：第一重很明显，当一个进程终止时，它所创建的锁全部释放；第二重则不太明显，无论一个描述符何时关闭，该进程通过这一描述符引用文件上的任何一把锁都会释放（这些锁都是该进程设置的），也就是说：该进程对该文件加的所有读写锁都会被释放（dup也好， open也好，全玩儿完）。 
	2. 由 fork 产生的子进程不继承父进程所设置的锁。 
	3. 在执行 exec 后， 新进程可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，那么作为exec的一部分关闭文件描述符时，将释放相应文件的所有锁。 

**建议锁和强制锁**：
	1. 建议性锁： 建议锁需要所有对文件的访问操作都使用统一函数（加了锁的），但是它不能阻止另一个不使用这些加锁函数而且对相应文件有修改权限的进程破坏锁的机制。
	2. 强制性锁：强制性锁会让内核检查每一个 `open`, `read` 和 `write`， 验证调用进程是否违背了长在访问的文件的某一把锁。(Linux 中需要在各文件系统基础上用 `mount -o mand` 命令打开强制性锁机制)。

### 比较
什么时候选用读写锁，什么时候选用自选锁，什么时候选用屏障，这些判断条件都很明确。 下面讨论一下什么时候选用 互斥锁，条件变量，信号量，记录锁的情况。 

1. 互斥锁必须总是由给它上锁的线程解锁，而信号量的wait和post不必由同一线程执行。 
2. 互斥要么被锁住，要么被解开，和二值信号量类似。 
3. 条件变量在发送信号时，如果没有线程在等待该条件变量，那么信号将丢失；而信号量有计数值，每次信号量 post操作都会被记录。 
4. （信号量）sem_post 是各种同步技巧中，唯一一个能在信号处理程序中安全调用的函数。 
5. 互斥锁是为上锁而优化的；条件变量是为等待优化的；信号量即可用于上锁，也可用户等待，因此会有更多的开销和更好的复杂性。 
6. 在对进程间共享内存区进行同步时，用记录锁比较好些，因为它语法简单明确，不易出错。 

<br/>
#### 参考资料
- 《深入理解计算机系统 原书2th》(CSAPP)
- 《Unix环境高级编程 3th》(APUE)
- 《Unix网络编程 3th, 卷二》(UNP)

<br/>
<br/>