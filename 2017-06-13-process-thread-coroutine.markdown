---
layout:     post
title:      "进程 线程 IO多路复用与协程"
subtitle:   "简要的对进程，线程，IO多路复用和协程进行总结和辨析"
date:       2017-06-13
author:     "ChenWenKe"
header-img: "img/post-bg-think-deeply.jpg"
tags:
    - OS
    - 网络编程
---

#### 进程
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。用这种方法进程并发编程时，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的**进程间通信（interprocess communication, IPC）**机制。
 

#### IO多路复用 
I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。 因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。

#### 线程
线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程时运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间。

#### 协程
协程可以被认为是一种用户空间线程。Coroutine（协程）是编译器级的， 是编译器的魔术，通过插入相关的代码使得代码段能够实现分段式的执行。

也许举例说明更形象些：
现在假设我们有3个协程A,B,C分别要进行数次IO操作。这3个协程运行在同一个调度器(线程)的上下文中，并依次使用CPU。协程A首先运行，当它执行到一个IO操作，但该IO操作并没有立即就绪时，A将该IO事件注册到调度器中，并主动放弃CPU。这时调度器将B切换到CPU上开始执行，同样，当它碰到一个IO操作的时候将IO事件注册到调度器中，并主动放弃CPU。调度器将C切换到cpu上开始执行。当所有协程都被“阻塞”后，调度器检查注册的IO事件是否发生或就绪。假设此时协程B注册的IO事件已经就绪，调度器将恢复B的执行，B将从上次放弃CPU的地方接着向下运行。A和C同理。这样，对于某个协程而言，我们采用的是同步的模型；但是对于整个调度器（线程）而言，实际上却是异步的模型。

**调度器：**一个线程运行一个调度器，可以在一个调度器上创建若干个协程。调度器负责调度这些协程。并且调度器在其内部维护了一个多路复用器（epoll/select/poll）。

#### 比较
Process 和 Thread 是操作系统级的。 Process 和 Thread 看起来也是在语言层次，但是内部原理却是操作系统先有这个东西，然后通过一定的 API暴露给用户使用，两者在这里有不同。 Process 和 Thread 是 OS通过调度算法，保存当前上下文，然后从上次暂停的地方再次开始执行，重新开始的地方不可预期，每次CPU计算的指令数量和代码跑过的CPU时间是相关的，跑到OS分配的CPU时间到达后会被OS强制挂起。

IO多路复用几乎全是编程级的，由程序员实现状态机。 协程是编译器级的，通过调度器使代码分段式执行。

#### 进程的优缺点
- 优点： 对于在父，子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟存储器，这就消除了许多令人迷惑的错误 ---- 这是一个明显的优点。

- 缺点： 另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的IPC(进程间通信)机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和IPC的开销很高。

**备注：** 常见的Unix IPC 方式有管道（有名管道，无名管道）， 消息队列，共享存储器（显式共享，隐式共享），信号量。

#### IO多路复用的优缺点
- 优点：事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。另一个优点是，一个基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的。因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得容易。一个与作为单进程运行相关的优点是，你可以利用熟悉的调试工具，例如 GDB, 来调试你的并发程序，就像调试顺序程序那样。另外，事件驱动设计常常比基于进程的设计高效得多，因为它们不需要进程上下文切换来调度新的流。

- 缺点：一个明显的缺点就是编码复杂，例如修改事件驱动服务器来处理部分文本行并不是一个简单的任务，但是基于进程的设计却能处理的很好，而且是自动处理的。基于事件的另一个重大缺点是它们不能充分利用多核处理器。 

#### 线程的优缺点
- 优点：无需跨进程边界； 程序逻辑和控制方式简单；所有线程可以直接共享内存和变量等；线程方式消耗的总资源比进程少。

- 缺点：每个线程和主程序公共地址空间，即地址空间受限；线程之间的同步和加锁控制比较麻烦；一个线程的崩溃可能影响到整个程序的稳定性；到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数； 线程能够提高的总性能有限，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU。

#### 协程的优缺点

与传统的线程相比，有2个主要的优点：
- 与线程不同，协程是自己主动让出 CPU, 并交付他期望的下一个协程运行，而不是在任何时候都可能被系统调度打断。因此协程的使用更加清晰移动，并且多数情况下不需要锁机制。
- 与线程相比，协程的切换由程序控制，发生在用户空间而非内核空间，因此切换的代价非常小。 

其他优点：
- 跨平台
- 跨体系架构
- 无需线程上下文切换的开销
- 无需原子操作锁定及同步的开销
- 方便切换控制流，简化编程模型
- 高并发+高扩展性+低成本：一个 CPU 支持上万的协程都不是问题。所以很适合用于高并发处理。

缺点：
- 无法利用多核资源：协程的本质是个单线程，它不能同时将 单个CPU的多个核用上，写成需要和进程配合才能运行在多个CPU上。当然我们日常所编写的绝大部分应用都没有这个必要，除非是CPU密集型应用。
- 进程阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决。


#### 参考资料

- [C++协程与网络编程](http://blog.csdn.net/woshiqjs/article/details/24124325)
- [浅谈我对协程的理解](http://blog.csdn.net/qq910894904/article/details/41699541)
- [一种协程的C/C++实现](http://www.cnblogs.com/Pony279/p/3903048.html) 
- [多进程和多线程的优缺点](http://www.cnblogs.com/Yogurshine/p/3640206.html)
- 《深入理解计算机系统 原书2th》(CSAPP) 12章-并发编程
