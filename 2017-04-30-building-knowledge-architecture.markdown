---
layout:     post
title:      "构建知识架构(草稿)"
subtitle:   "琐碎，杂乱，庞大的事物，只有整理过，清晰了，明确了，洞然了，才能得心应手，否则徒增困惑而已！"
date:       2017-04-29
author:     "ChenWenKe"
header-img: "img/post-bg-cattle.jpg"
tags:
    - OS
    - 设计
    - 编程思想
    - 生活
    - 感悟
    - 哲思
---

> Do one thing, do it well.  —— Unix 哲学

#### 引子

琐碎，杂乱，庞大的事物，只有整理过，清晰了，明确了，洞然了，才能发挥出爆表的力量。正如乌合之众只会叽叽喳喳，即使让他们讨论上上百年，最终也只能是莫衷一是，一事无成。 凌乱的知识碎片也是一样，除了徒增困惑，简直一无是处。

更可怕的是，西瓜大的脑袋中装入了冬瓜多的知识碎片时，容易让人沾沾自喜，自命不凡（笔者以前正是这样，也许现在也还是这样，所以现在在写这些夸夸其谈的文字）, 自以为知道的很多，但其实都是**拿来的主义**，都是别人的观点，自己只是在简单的鹦鹉学舌强逞口舌之快而已。话说这种讨厌的“鸟人”，除了沦为玩物之外有何用处。

碎片化的知识往往容易让人产生偏见，因为碎片化的知识往往只从一个观点和角度出发，并且不断的对这一个观点进行强化，而且只是简单的枚举那些佐证其片面观点的论据。这样就让读者自然而然的陷入了笔者的思维轨道，从而失去了对事件或事件整体性的把握和思考（即通常说的大局观）。 所以长大后就常听到一句话：**小孩子才说对错，成年人只讲权衡**。很多事情都不是非黑即白的，正如我们不能告诉一个食人族吃人是不对的一样。 

但是，凡事都是从一片无知中开始的，所以开始时必然是混沌，庞杂，凌乱的。各个击破的军事策略告诉我们，我们一口是吃不成一个三胖滴，当然如果你是遗传（世袭或拼爹），我无话可说。 所以我们的认知开始必然是琐碎的，碎片化的。 但是随着时间的积累，当我们有足够的知识储备建立起知识构架时，我们却陷入了各个知识点的细枝末节之中无法逃脱。不管你信或不信，我们就是这么傻得可爱，事实就是如此！

举个很明显的例子：试想一下，我们经过 12 年的应试教育的摧残，怀揣着热切蓬勃梦想进入大学，却单单是为了打四年游戏和一张不知道有没有用的文凭。 想想我们高三的付出和当时的憧憬，对比一下现在的状态和对未来的规划，是不是很讽刺？  

再举个小例子：我们往往想通过辩论去说服别人，但往往适得其反（特别是当你完美的赢得了辩论的时候）。 因为，别人记得的并不是什么事实（the truth），而是和你相处的感受。啊哈！人们竟然只在乎自身的感受，而并不关心对错，是不是很讽刺？即使你明明知道了这个道理，但是你还是马不停蹄的，眉飞色舞的，手舞足蹈的要去展现出你睿智的观点，犀利的言辞，然后引起别人强烈的嫉妒和反感，是不是很讽刺？ 

不管你信或者不信，我们总是这么愚蠢的背离初衷，我们曾经的热血和豪情，或陷入无限的细节中无法自知，或在漫长的琐屑中消磨殆尽！ 而我们却活像一头蒙眼拉磨的驴子，靠着习惯一步一步的向前走，是不是很讽刺？


> 所以说选择大于努力，方向和目标永远是最重要的（也许要除却生死问题）

#### 从学编程谈起

> 方向和目标的明确建立在不断的反思和总结之上。 

这里通过对一个简单程序的执行过程的描述，我试试能不能搭起自己的知识构架（即：逻辑清晰的把所学的姿势应用出来），如果不能，说明我头脑中的知识片段仍然是片段，仍然是一碗浆糊，仍然没有理解。**对一件事物的真正理解的明显标志就是能够清晰而简洁的表达。** 

```cpp
// hello.c
#include <stdio.h>
int main(int argc, char** argv)
{
	printf("Hello World!\n"); 
	return 0; 
}
```

##### 第一层理解

第一层理解，就是C/C++老师通常讲的那样，略去不提。 

##### 第二层理解
上面的文件是个文本文件，需要经过编译链接生成可执行文件之后，才能执行。 

编译过程：`预处理 --> 编译 --> 汇编 --> 链接 --> 生成可执行文件`

对应的 gcc命令：
- 预处理： `gcc -E` 若要保留注释：`gcc -E -C` 替换宏和处理头文件（及注释）
- 编译：`gcc -S` 生成汇编代码。 
- 汇编：`gcc -c` 生成可重定位的二进制代码。 
- 链接：`gcc ` 生成可执行可链接二进制代码（ELF）

**扩展**其他 gcc 常用选项：

- 源码中保留调试信息：`gcc -g`
- 指定优化等级：`gcc -On`, n 为数字 1,2,3等，默认是2。 
- 指定文件目录：`gcc -I /dir`
- 指定链接库目录： `gcc -L `
- 静态链接：`gcc -static`
- 生成静态库：`ar rcs libvector.a addvec.o multvec.o` 后三个参数是举例文件。
- 生成共享库：`gcc -shared -fPIC -o libvector.so addvec.c multvec.c`


**Hello World!**一般存放在内存的只读数据区
虚拟地址空间中的进程模型：
- 内核代码（用户不可见）
- 用户栈
- 共享库
- 用户堆
- 用户数据段
- 用户代码段

程序中的`printf`一般是作为共享库加载进存储器的。即：在进程运行时，所有用到`printf`的进程，共同使用存储器中的同一份 printf代码。 这样程序的代码在内存中就完整了，因此可以执行了。 

##### 第三层理解
程序代码开始时是躺在磁盘上的，但是代码如果要运行，需要把它们搞到存储器中去。 另外，程序是静态的代码，但是程序代码如果想要运行，需要获得一些资源，并且由OS进行这些资源的调度与分配，因此程序代码是在进程中运行的。 
**进程的概念：**
进程是计算机体系中最成功的抽象之一, 可以把进程看做一个独立的逻辑流，拥有独立的虚拟地址空间，好像每个进程都在独自的占用CPU. 
把上面的 ELF文件(经编译链接生成的可执行可链接文件) **加载** 进存储器中后，让程序计数器指向程序的入口地址，完美！我们的小程序就运行起来了。 

**fork进程：**
**加载的概念：**

##### 第四层理解
再度细分一下，加入说我们输入：`gcc hello.c`已经生成了 ELF 文件: `a.out`。 现在我们输入：`./a.out` 很显然终端会输出`Hello World!` 但是这期间又发生了多少隐晦微妙的故事呢？

- 首先当前shell会解释./a.out，检查a.out文件再当前目录下是否存在，读取该文件的i节点，检测一些权限信息如（是否可执行，属于那个用户，哪个组。。。），前面都没问题，调用 fork 为该程序的运行生成一个进程。
- 然后调用 execve 加载程序，这时，需要查找磁盘上 a.out 的数据块（程序中以域或段组织），把相应的段映射到虚拟存储器中，a.out文件中有些段没有映射到虚拟存储器，例如：调试信息.debug, 符号表信息等。 正如上面所说的那样，加载过程中除了一些头部表信息外，没有磁盘到存储器的数据拷贝。
- 紧接着进程中的代码的虚拟地址被访问，由于实际上a.out并没有被拷贝进存储器，引发了一个缺页异常。系统的页面调度机制把磁盘上的a.out的相应的段拷贝到存储器中，并更新页表，然后缺页异常返回，程序再次执行刚刚引起缺页异常的那条指令，程序正常执行。
- 进程把只读数据区中的字符串“Hello World!”拷贝进标准输出缓冲区，由于标准输出是**行缓存**的, 所以`\n`换行符刷新缓冲区，“Hello World!”被输出到标准输出。 然后执行`return 0;`程序从 main 中返回。 把结束标志传给操作系统。 程序正常结束。

##### 第五层理解
当shell解释 a.out 时，会调用 文件 a.out的i节点里存储的信息，其实这里面有很多信息（如：文件类型，三组权限，文件的实际用户，文件的有效用户，设置-用户-id等），而且查找的过程牵涉到**文件的体系结构**。 找到文件后（读取i节点信息后）还要和当前进程的实际用户，有效用户等权限进行比较，这又涉及到**进程控制**。程序的执行都是需要首先加载进存储器的，所以这就很自然的涉及到了**虚拟存储器**，另外，系统中并不只有我们这一个进程有些**守护进程**和其他的一些进程一直都在后台运行着的，既然有多个进程，所以理所当然的需要进程的调度，这就又涉及到**异常控制流**，既然系统需要调度各个进程，它就需要和各个进程之间通信，而且各个进程之间有时也需要进行通信这就涉及到了**信号**和各种**IPC**。

另外加载器把 a.out 映射到虚拟存储器之后，并没有把直接指向程序的入口，而是调用了系统中的一个启动例程**`exit(main(argc, argv))`**, 程序执行结束后（也可能被某些信号中断）可以直接调用`_exit()`函数或`_Exit()`函数直接结束，也可以执行`exit`函数，它先执行由`atexit(func)`函数登记的终止处理程序，最后再调用`_exit()或_Exit()`函数结束进程。

程序中涉及到把字符串输出到标准输出，这就涉及到了**标准I/O**, 标准I/O又都调用了**文件I/O**。 这就涉及到标准I/O的各种缓存问题以及I/O的关闭和打开在进程fork时，进程运行结束时，会发生怎样的情况的很多琐碎而微妙的问题。 还有，进程结束后需要父进程（或者init进程）进行回收。这又牵涉到**进程之间的关系**。 

##### 对第五层的知识点小结

- 文件系统
- 进程控制
- 虚拟存储器
- 异常控制流
- 守护进程
- 异常控制流
- 信号
- IPC
- 程序的启动和终止
- 标准I/O
- 文件I/O
- 进程间的关系 

一个小小的`Hello World`就能牵涉到这么多系统的知识，可见编程的知识点都是染到一块的，不仅多，而且杂，更可怕的是它们都交织在一块儿。**世间的事，难就难在你中有我，我中有你。--- 《大明王朝1566》胡宗宪**
况且这还只是技术问题，更难的是关于人的问题。 
> 我们习惯地专注于工作中的技术问题，并非因为它们重要，而是因为它们更简单。   —— 《人件》

#### 说说设计

#### 聊聊世界观和方法论

#### 暂且吟啸徐行

### 参考书籍
- 《计算机操作系统 4th》汤小丹等著
- 《深入理解计算机系统 2th》
- 《Unix 网络编程 3th 卷一》 Stevens 等
- 《Unix 网络编程 2th 卷二》 Strvens 
- 《Unix 环境高级编程 1th》Strvens 
- 《艺术的故事》
- 《万历十五年》黄仁宇
- 《从0到1》彼特.蒂尔
- 《别闹了，费曼先生》 费曼
- 《禅与摩托车修理艺术》（又名“万里任禅游”）