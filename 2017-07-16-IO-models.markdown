---
layout:     post
title:      "阻塞I/O VS 非阻塞I/O VS 同步I/O VS 异步I/O"
subtitle:   "阻塞事I/O, 非阻塞式I/O, 同步I/O, 异步I/O 简要总结"
date:       2017-07-16
author:     "ChenWenKe"
header-img: "img/post_csapp/vm.jpg"
tags:
    - Linux
    - OS
    - 网络编程
---

#### 阻塞I/O VS 非阻塞I/O VS 同步I/O VS 异步I/O

### 阻塞 I/O 模型
最流行的I/O模型就是阻塞式I/O(blocking I/O)模型。 默认情况下，所有套接字都是阻塞的。 对于读操作而言， 在内核准备数据（如从网卡上接收数据）期间，以及内核数据准备好后，数据从内核复制到用户空间期间，进程一直阻塞。同理，写操作与此类似。

换种通俗的，不准确的方式来说就是： 当应用“缓冲区为空时”，进程将阻塞于 读操作；当应用“缓冲区为满时”，进程将阻塞于“写操作”。 
### 非阻塞式 I/O 模型
进程把一个套接字设置成非阻塞是在通知内核：当所请求的 I/O 操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。 
同样以读操作来说： 在内核准备数据期间，进程不断轮询内核“数据准备好了没？”， 如果没有，读操作就返回一个错误。如果准备好了，内核就把数据复制到用户空间中，读操作成功返回。

### 同步 I/O 模型
导致请求进程阻塞，直到I/O操作完成。注意，从内核复制数据到应用进程缓冲区期间的阻塞也算阻塞。 也就是说，阻塞式I/O和非阻塞式I/O都是同步I/O 模型。 

### 异步 I/O 模型
不导致请求进程阻塞。 也就是说，即使是在内核复制数据到应用进程缓冲区期间进程也没有被阻塞。 

<br/>
#### 参考资料
- 《Unix 网络编程 3th, 卷一》

<br/>
<br/>
